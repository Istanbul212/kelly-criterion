{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport useIsomorphicLayoutEffect from '../hooks/useIsomorphicLayoutEffect';\nimport useChartContext from '../utils/chartContext';\n\nvar getElBox = function getElBox(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    top: Math.round(rect.top),\n    right: Math.round(rect.right),\n    bottom: Math.round(rect.bottom),\n    left: Math.round(rect.left),\n    width: Math.round(rect.width),\n    height: Math.round(rect.height),\n    x: Math.round(rect.x),\n    y: Math.round(rect.y)\n  };\n};\n\nexport default function useMeasure(_ref) {\n  var axis = _ref.axis,\n      elRef = _ref.elRef,\n      gridDimensions = _ref.gridDimensions,\n      setShowRotated = _ref.setShowRotated;\n\n  var _useChartContext = useChartContext(),\n      axisDimensionsState = _useChartContext.axisDimensionsState;\n\n  var axisDimensions = axisDimensionsState[0],\n      setAxisDimensions = axisDimensionsState[1];\n  var axisDimension = React.useMemo(function () {\n    var _axisDimensions;\n\n    return (_axisDimensions = axisDimensions[axis.position]) == null ? void 0 : _axisDimensions[axis.id];\n  }, [axisDimensions, axis.position, axis.id]); // const isLooping = useIsLooping()\n\n  var measureRotation = React.useCallback(function () {\n    var _widestLabel2;\n\n    if (!elRef.current) {\n      return;\n    }\n\n    var gridSize = !axis.isVertical ? gridDimensions.gridWidth : gridDimensions.gridHeight;\n    var staticLabelDims = Array.from(elRef.current.querySelectorAll('.Axis-Group.outer .tickLabel')).map(function (el) {\n      return getElBox(el);\n    }); // Determine the largest labels on the axis\n\n    var widestLabel;\n    staticLabelDims.forEach(function (label) {\n      var _widestLabel;\n\n      var resolvedLabel = (_widestLabel = widestLabel) != null ? _widestLabel : {\n        width: 0\n      };\n\n      if (label.width > 0 && label.width > resolvedLabel.width) {\n        widestLabel = label;\n      }\n    });\n    var smallestTickGap = gridSize;\n\n    if (staticLabelDims.length > 1) {\n      staticLabelDims.forEach(function (current, i) {\n        var prev = staticLabelDims[i - 1];\n\n        if (prev) {\n          smallestTickGap = Math.min(smallestTickGap, axis.isVertical ? current.top - prev.top : current.left - prev.left);\n        }\n      });\n    }\n\n    var shouldRotate = (((_widestLabel2 = widestLabel) == null ? void 0 : _widestLabel2.width) || 0) + axis.minTickPaddingForRotation > smallestTickGap; // if (!isLooping) {\n    // Rotate ticks for non-time horizontal axes\n\n    if (!axis.isVertical) {\n      setShowRotated(shouldRotate);\n    } // }\n\n  }, [elRef, axis.isVertical, axis.minTickPaddingForRotation, gridDimensions.gridWidth, gridDimensions.gridHeight, setShowRotated]);\n  var measureDimensions = React.useCallback(function () {\n    if (!elRef.current) {\n      if (axisDimension) {\n        // If the entire axis is hidden, then we need to remove the axis dimensions\n        setAxisDimensions(function (old) {\n          var _old$axis$position, _extends2;\n\n          var newAxes = _extends({}, (_old$axis$position = old[axis.position]) != null ? _old$axis$position : {});\n\n          delete newAxes[axis.id];\n          return _extends({}, old, (_extends2 = {}, _extends2[axis.position] = newAxes, _extends2));\n        });\n      }\n\n      return;\n    }\n\n    var newDimensions = {\n      width: 0,\n      height: 0,\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n    var domainEl = elRef.current.querySelector(\".Axis-Group.inner .domain\");\n\n    if (!domainEl) {\n      return;\n    }\n\n    var domainDims = getElBox(domainEl);\n    var measureDims = Array.from(elRef.current.querySelectorAll('.Axis-Group.inner .tickLabel')).map(function (el) {\n      return getElBox(el);\n    }); // Determine the largest labels on the axis\n\n    var widestRealLabel = measureDims[0];\n    var tallestRealLabel = measureDims[0];\n    measureDims.forEach(function (d) {\n      if (d.width > 0 && d.width > widestRealLabel.width) {\n        widestRealLabel = d;\n      }\n\n      if (d.height > 0 && d.height > tallestRealLabel.height) {\n        tallestRealLabel = d;\n      }\n    }); // Axis overflow measurements\n\n    if (!axis.isVertical) {\n      var _tallestRealLabel$hei, _tallestRealLabel;\n\n      if (measureDims.length) {\n        var leftMostLabelDim = measureDims.reduce(function (d, labelDim) {\n          return labelDim.left < d.left ? labelDim : d;\n        });\n        var rightMostLabelDim = measureDims.reduce(function (d, labelDim) {\n          return labelDim.right > d.right ? labelDim : d;\n        });\n        newDimensions.left = Math.round(Math.max(0, domainDims.left - (leftMostLabelDim == null ? void 0 : leftMostLabelDim.left)));\n        newDimensions.right = Math.round(Math.max(0, (rightMostLabelDim == null ? void 0 : rightMostLabelDim.right) - domainDims.right));\n      }\n\n      newDimensions.height = Math.round( // Math.max(axis.tickSizeInner, axis.tickSizeOuter) +\n      8 + axis.minTickPaddingForRotation + ((_tallestRealLabel$hei = (_tallestRealLabel = tallestRealLabel) == null ? void 0 : _tallestRealLabel.height) != null ? _tallestRealLabel$hei : 0));\n    } else {\n      var _widestRealLabel$widt, _widestRealLabel;\n\n      if (measureDims.length) {\n        var topMostLabelDim = measureDims.reduce(function (d, labelDim) {\n          return labelDim.top < d.top ? labelDim : d;\n        });\n        var bottomMostLabelDim = measureDims.reduce(function (d, labelDim) {\n          return labelDim.bottom > d.bottom ? labelDim : d;\n        });\n        newDimensions.top = Math.round(Math.max(0, domainDims.top - (topMostLabelDim == null ? void 0 : topMostLabelDim.top)));\n        newDimensions.bottom = Math.round(Math.max(0, (bottomMostLabelDim == null ? void 0 : bottomMostLabelDim.bottom) - domainDims.bottom));\n      }\n\n      newDimensions.width = Math.round( // Math.max(axis.tickSizeInner, axis.tickSizeOuter) +\n      8 + axis.minTickPaddingForRotation + ((_widestRealLabel$widt = (_widestRealLabel = widestRealLabel) == null ? void 0 : _widestRealLabel.width) != null ? _widestRealLabel$widt : 0));\n    } // Only update the axisDimensions if something has changed\n\n\n    if ( // !isLooping &&\n    !axisDimensions || !axisDimension || Object.keys(newDimensions).some(function (key) {\n      // @ts-ignore\n      return newDimensions[key] !== axisDimension[key];\n    })) {\n      setAxisDimensions(function (old) {\n        var _old$axis$position2, _extends3, _extends4;\n\n        return _extends({}, old, (_extends4 = {}, _extends4[axis.position] = _extends({}, (_old$axis$position2 = old[axis.position]) != null ? _old$axis$position2 : {}, (_extends3 = {}, _extends3[axis.id] = newDimensions, _extends3)), _extends4));\n      });\n    }\n  }, [axis.id, axis.isVertical, axis.position, axis.minTickPaddingForRotation, axisDimension, axisDimensions, elRef, setAxisDimensions]); // Measure after if needed\n\n  useIsomorphicLayoutEffect(function () {\n    measureRotation();\n  }, [measureRotation]);\n  useIsomorphicLayoutEffect(function () {\n    measureDimensions();\n  }, [measureRotation]);\n}","map":{"version":3,"sources":["/Users/samerkadih/Desktop/Coding/Personal/React/kelly-criterion/node_modules/react-charts/es/components/AxisLinear.useMeasure.js"],"names":["_extends","React","useIsomorphicLayoutEffect","useChartContext","getElBox","el","rect","getBoundingClientRect","top","Math","round","right","bottom","left","width","height","x","y","useMeasure","_ref","axis","elRef","gridDimensions","setShowRotated","_useChartContext","axisDimensionsState","axisDimensions","setAxisDimensions","axisDimension","useMemo","_axisDimensions","position","id","measureRotation","useCallback","_widestLabel2","current","gridSize","isVertical","gridWidth","gridHeight","staticLabelDims","Array","from","querySelectorAll","map","widestLabel","forEach","label","_widestLabel","resolvedLabel","smallestTickGap","length","i","prev","min","shouldRotate","minTickPaddingForRotation","measureDimensions","old","_old$axis$position","_extends2","newAxes","newDimensions","domainEl","querySelector","domainDims","measureDims","widestRealLabel","tallestRealLabel","d","_tallestRealLabel$hei","_tallestRealLabel","leftMostLabelDim","reduce","labelDim","rightMostLabelDim","max","_widestRealLabel$widt","_widestRealLabel","topMostLabelDim","bottomMostLabelDim","Object","keys","some","key","_old$axis$position2","_extends3","_extends4"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport useIsomorphicLayoutEffect from '../hooks/useIsomorphicLayoutEffect';\nimport useChartContext from '../utils/chartContext';\n\nvar getElBox = function getElBox(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    top: Math.round(rect.top),\n    right: Math.round(rect.right),\n    bottom: Math.round(rect.bottom),\n    left: Math.round(rect.left),\n    width: Math.round(rect.width),\n    height: Math.round(rect.height),\n    x: Math.round(rect.x),\n    y: Math.round(rect.y)\n  };\n};\n\nexport default function useMeasure(_ref) {\n  var axis = _ref.axis,\n      elRef = _ref.elRef,\n      gridDimensions = _ref.gridDimensions,\n      setShowRotated = _ref.setShowRotated;\n\n  var _useChartContext = useChartContext(),\n      axisDimensionsState = _useChartContext.axisDimensionsState;\n\n  var axisDimensions = axisDimensionsState[0],\n      setAxisDimensions = axisDimensionsState[1];\n  var axisDimension = React.useMemo(function () {\n    var _axisDimensions;\n\n    return (_axisDimensions = axisDimensions[axis.position]) == null ? void 0 : _axisDimensions[axis.id];\n  }, [axisDimensions, axis.position, axis.id]); // const isLooping = useIsLooping()\n\n  var measureRotation = React.useCallback(function () {\n    var _widestLabel2;\n\n    if (!elRef.current) {\n      return;\n    }\n\n    var gridSize = !axis.isVertical ? gridDimensions.gridWidth : gridDimensions.gridHeight;\n    var staticLabelDims = Array.from(elRef.current.querySelectorAll('.Axis-Group.outer .tickLabel')).map(function (el) {\n      return getElBox(el);\n    }); // Determine the largest labels on the axis\n\n    var widestLabel;\n    staticLabelDims.forEach(function (label) {\n      var _widestLabel;\n\n      var resolvedLabel = (_widestLabel = widestLabel) != null ? _widestLabel : {\n        width: 0\n      };\n\n      if (label.width > 0 && label.width > resolvedLabel.width) {\n        widestLabel = label;\n      }\n    });\n    var smallestTickGap = gridSize;\n\n    if (staticLabelDims.length > 1) {\n      staticLabelDims.forEach(function (current, i) {\n        var prev = staticLabelDims[i - 1];\n\n        if (prev) {\n          smallestTickGap = Math.min(smallestTickGap, axis.isVertical ? current.top - prev.top : current.left - prev.left);\n        }\n      });\n    }\n\n    var shouldRotate = (((_widestLabel2 = widestLabel) == null ? void 0 : _widestLabel2.width) || 0) + axis.minTickPaddingForRotation > smallestTickGap; // if (!isLooping) {\n    // Rotate ticks for non-time horizontal axes\n\n    if (!axis.isVertical) {\n      setShowRotated(shouldRotate);\n    } // }\n\n  }, [elRef, axis.isVertical, axis.minTickPaddingForRotation, gridDimensions.gridWidth, gridDimensions.gridHeight, setShowRotated]);\n  var measureDimensions = React.useCallback(function () {\n    if (!elRef.current) {\n      if (axisDimension) {\n        // If the entire axis is hidden, then we need to remove the axis dimensions\n        setAxisDimensions(function (old) {\n          var _old$axis$position, _extends2;\n\n          var newAxes = _extends({}, (_old$axis$position = old[axis.position]) != null ? _old$axis$position : {});\n\n          delete newAxes[axis.id];\n          return _extends({}, old, (_extends2 = {}, _extends2[axis.position] = newAxes, _extends2));\n        });\n      }\n\n      return;\n    }\n\n    var newDimensions = {\n      width: 0,\n      height: 0,\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n    var domainEl = elRef.current.querySelector(\".Axis-Group.inner .domain\");\n\n    if (!domainEl) {\n      return;\n    }\n\n    var domainDims = getElBox(domainEl);\n    var measureDims = Array.from(elRef.current.querySelectorAll('.Axis-Group.inner .tickLabel')).map(function (el) {\n      return getElBox(el);\n    }); // Determine the largest labels on the axis\n\n    var widestRealLabel = measureDims[0];\n    var tallestRealLabel = measureDims[0];\n    measureDims.forEach(function (d) {\n      if (d.width > 0 && d.width > widestRealLabel.width) {\n        widestRealLabel = d;\n      }\n\n      if (d.height > 0 && d.height > tallestRealLabel.height) {\n        tallestRealLabel = d;\n      }\n    }); // Axis overflow measurements\n\n    if (!axis.isVertical) {\n      var _tallestRealLabel$hei, _tallestRealLabel;\n\n      if (measureDims.length) {\n        var leftMostLabelDim = measureDims.reduce(function (d, labelDim) {\n          return labelDim.left < d.left ? labelDim : d;\n        });\n        var rightMostLabelDim = measureDims.reduce(function (d, labelDim) {\n          return labelDim.right > d.right ? labelDim : d;\n        });\n        newDimensions.left = Math.round(Math.max(0, domainDims.left - (leftMostLabelDim == null ? void 0 : leftMostLabelDim.left)));\n        newDimensions.right = Math.round(Math.max(0, (rightMostLabelDim == null ? void 0 : rightMostLabelDim.right) - domainDims.right));\n      }\n\n      newDimensions.height = Math.round( // Math.max(axis.tickSizeInner, axis.tickSizeOuter) +\n      8 + axis.minTickPaddingForRotation + ((_tallestRealLabel$hei = (_tallestRealLabel = tallestRealLabel) == null ? void 0 : _tallestRealLabel.height) != null ? _tallestRealLabel$hei : 0));\n    } else {\n      var _widestRealLabel$widt, _widestRealLabel;\n\n      if (measureDims.length) {\n        var topMostLabelDim = measureDims.reduce(function (d, labelDim) {\n          return labelDim.top < d.top ? labelDim : d;\n        });\n        var bottomMostLabelDim = measureDims.reduce(function (d, labelDim) {\n          return labelDim.bottom > d.bottom ? labelDim : d;\n        });\n        newDimensions.top = Math.round(Math.max(0, domainDims.top - (topMostLabelDim == null ? void 0 : topMostLabelDim.top)));\n        newDimensions.bottom = Math.round(Math.max(0, (bottomMostLabelDim == null ? void 0 : bottomMostLabelDim.bottom) - domainDims.bottom));\n      }\n\n      newDimensions.width = Math.round( // Math.max(axis.tickSizeInner, axis.tickSizeOuter) +\n      8 + axis.minTickPaddingForRotation + ((_widestRealLabel$widt = (_widestRealLabel = widestRealLabel) == null ? void 0 : _widestRealLabel.width) != null ? _widestRealLabel$widt : 0));\n    } // Only update the axisDimensions if something has changed\n\n\n    if ( // !isLooping &&\n    !axisDimensions || !axisDimension || Object.keys(newDimensions).some(function (key) {\n      // @ts-ignore\n      return newDimensions[key] !== axisDimension[key];\n    })) {\n      setAxisDimensions(function (old) {\n        var _old$axis$position2, _extends3, _extends4;\n\n        return _extends({}, old, (_extends4 = {}, _extends4[axis.position] = _extends({}, (_old$axis$position2 = old[axis.position]) != null ? _old$axis$position2 : {}, (_extends3 = {}, _extends3[axis.id] = newDimensions, _extends3)), _extends4));\n      });\n    }\n  }, [axis.id, axis.isVertical, axis.position, axis.minTickPaddingForRotation, axisDimension, axisDimensions, elRef, setAxisDimensions]); // Measure after if needed\n\n  useIsomorphicLayoutEffect(function () {\n    measureRotation();\n  }, [measureRotation]);\n  useIsomorphicLayoutEffect(function () {\n    measureDimensions();\n  }, [measureRotation]);\n}"]},"metadata":{},"sourceType":"module"}